% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={MUltlog 1.16 \& iLC 1.2 User Manual},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{listings}
\newcommand{\passthrough}[1]{#1}
\lstset{defaultdialect=[5.3]Lua}
\lstset{defaultdialect=[x86masm]Assembler}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\lstset{
    basicstyle=\ttfamily,
    breaklines=true,
    breakautoindent=true,
    showstringspaces=true,
    linewidth=\linewidth
}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{MUltlog 1.16 \& iLC 1.2 User Manual}
\author{}
\date{}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{2}
\tableofcontents
}
This manual is \href{https://logic.at/multlog/multlog.pdf}{available in
PDF} from the MUltlog website at
\href{https://logic.at/multlog}{logic.at/multlog}.

MUltlog is a system which takes as input the specification of a
finitely-valued first-order logic and produces a sequent calculus, a
tableau system, a natural deduction system, and clause formation rules
for this logic. All generated rules are optimized regarding their
branching degree. The output is in the form of a scientific paper
written in LaTeX.

iLC is an editor for Tcl/Tk, which allows to specify many-valued logics
for MUltlog in a convenient form.

Further information is available on the
\href{http://www.logic.at/multlog/}{project webpage}, where you can also
find an up-to-date copy of this manual, and example outputs.

\hypertarget{requirements}{%
\section{Requirements}\label{requirements}}

You need the following to run MUltlog:

\begin{itemize}
\item
  MUltlog itself. The source code is available in the
  \href{https://github.com/rzach/multlog}{Multlog GitHub repository}.
\item
  Some standard Prolog system,
  e.g.~\href{https://www.swi-prolog.org/}{SWI-Prolog}. Other Prologs
  might work as well but have not been tested with recent versions of
  MUltlog.
\end{itemize}

The output of MUltlog is in the form of a LaTeX paper. To view it
properly, you need the typesetting system

\begin{itemize}
\tightlist
\item
  TeX, available from \href{https://ctan.org/}{CTAN}. For Linux, the
  \href{https://www.tug.org/texlive/}{TeXLive} distribution is
  particularly convenient to install and is most likely available via
  your package manager.
\end{itemize}

MUltlog includes a special editor, iLC, which allows to specify
many-valued logics in a convenient, windows-oriented way, instead of
typing an ASCII text in a strict syntax. To use this editor you need the
script language

\begin{itemize}
\tightlist
\item
  \href{https://www.tcl.tk/}{Tcl/Tk} (version 7.4/4.0 or later). Many
  Linux systems include Tcl/Tk by default (check for a program named
  \passthrough{\lstinline!wish!}).
\end{itemize}

On Debian/Ubuntu Linux, for instance, you can install the requirements
using the command

\begin{lstlisting}
sudo apt install swi-prolog tk texlive-latex-extra
\end{lstlisting}

\hypertarget{installation}{%
\section{Installation}\label{installation}}

\hypertarget{obtaining-multlog}{%
\subsection{Obtaining MUltlog}\label{obtaining-multlog}}

Get the newest release of MUltlog by cloning or downloading the Git
repository from
\href{https://github.com/rzach/multlog}{github.com/rzach/multlog}.

\hypertarget{running-the-installation-script}{%
\subsection{Running the installation
script}\label{running-the-installation-script}}

As of version 1.05, MUltlog comes with an installation script for Linux.
Before running the script:

\begin{itemize}
\item
  decide which Prolog to use. The script will look for SWI-Prolog,
  SICStus, and BinProlog in some standard locations, and suggest the
  result as a default to the user.
\item
  decide where to put MUltlog. If run as root, the default locations are
  \passthrough{\lstinline!/usr/local/bin!} for executables,
  \passthrough{\lstinline!/usr/local/lib!} for library files, and
  \passthrough{\lstinline!/usr/share/doc!} for documentation. If not run
  as root, the script will install into
  \passthrough{\lstinline!\~/.local/bin,!}
  \passthrough{\lstinline!\~/.local/lib!}, and
  \passthrough{\lstinline!\~/.local/doc!}. Note that these directories
  must exist; the script will not try to create them.
\end{itemize}

To run the installation script, change to the installation directory
\passthrough{\lstinline!multlog!} and type

\begin{lstlisting}
./ml_install
\end{lstlisting}

The script will - determine the location of some Unix commands - ask the
user for the Prolog to use - ask the user for the place where to put
MUltlog - generate the deinstallation script
\passthrough{\lstinline!ml\_deinstall!} - insert the correct paths in
some of MUltlog's files - copy the MUltlog files in the right places.

In case of problems see the section on
\protect\hyperlink{troubleshooting}{troubleshooting} below.

Note that the installation procedure puts path information directly into
some of MUltlog's files. This means that to install MUltlog somewhere
else, you need the original distribution as well as the installation
script.

\hypertarget{deinstallation}{%
\subsection{Deinstallation}\label{deinstallation}}

Run the script

\begin{lstlisting}
ml_deinstall
\end{lstlisting}

to remove files installed by \passthrough{\lstinline!ml\_install!}. The
deinstallation script is located in the same directory as the other
MUltlog commands like \passthrough{\lstinline!lgc2tex!},
\passthrough{\lstinline!lgc2pdf!}, \ldots{}
(\passthrough{\lstinline!/usr/local/bin!} or
\passthrough{\lstinline!\~/.local/bin!} by default).

\hypertarget{using-multlog}{%
\section{Using MUltlog}\label{using-multlog}}

The examples below assume that MUltlog was installed into the standard
place \passthrough{\lstinline!/usr/local/*!}, and assumes that the
locations of the MUltlog scripts \passthrough{\lstinline!lgc2tex!} and
\passthrough{\lstinline!lgc2pdf!} are your command path. If you use
different settings, change the examples accordingly.

\hypertarget{guide-for-the-impatient}{%
\subsection{Guide for the impatient}\label{guide-for-the-impatient}}

\begin{itemize}
\item
  Move to a temporary directory, e.g.,

\begin{lstlisting}
mkdir tmp; cd tmp
\end{lstlisting}
\item
  Get the sample logic from the \passthrough{\lstinline!doc!} directory,
  e.g.,

\begin{lstlisting}
cp /usr/share/doc/multlog/sample.lgc .
\end{lstlisting}
\item
  Generate the paper in PDF format

\begin{lstlisting}
lgc2pdf sample
\end{lstlisting}

  You should now be able to open \passthrough{\lstinline!sample.pdf!}
  using the PDF reader of your choice.
\item
  To edit the specification of the logic before generating the paper,
  type

\begin{lstlisting}
ilc &
\end{lstlisting}

  Select ``Open'' from the menu ``File'' and type
  \passthrough{\lstinline!sample!} as the name of the file to be loaded.
\end{itemize}

The \passthrough{\lstinline!examples/!} directory of the distribution
contains other example specification and configuration files.

\hypertarget{creating-the-specification-of-a-logic}{%
\subsection{Creating the specification of a
logic}\label{creating-the-specification-of-a-logic}}

You can either use your favourite text editor, or the ``interactive
Logic Creator'' \passthrough{\lstinline!ilc!}.

In the first case specify your many-valued logic in the syntax described
in the sample specification
\passthrough{\lstinline!/usr/share/doc/multlog/sample.lgc!} and save the
result as \passthrough{\lstinline!<name>.lgc!}.

To start \passthrough{\lstinline!ilc!}, type

\begin{lstlisting}
ilc &
\end{lstlisting}

A window pops up, and you are able to edit a new logic or re-edit an
already exisiting one, and to save the result in a textual format
suitable for MUltlog. Note that you have to store the logic as
\passthrough{\lstinline!<name>!}, the extension
\passthrough{\lstinline!.lgc!} being added automatically.

\hypertarget{creating-the-paper-pdf}{%
\subsection{Creating the paper (PDF)}\label{creating-the-paper-pdf}}

To obtain the paper corresponding to your logic, type

\begin{lstlisting}
lgc2pdf <name>
\end{lstlisting}

where \passthrough{\lstinline!<name>!} is the name under which you saved
your logic. This invokes MUltlog as well as PDFLaTeX and BibTeX (or
alternatively, if \passthrough{\lstinline!pdflatex!} was not found upon
installation, LaTeX, BibTeX, \passthrough{\lstinline!dvips!} and
\passthrough{\lstinline!ps2pdf!}).

If \passthrough{\lstinline!<name>.bib!} exists, it should contain a
bibliography entry with key \passthrough{\lstinline!ml!}, which will be
cited as the source for the definition of the logic.

Additionally, all files are deleted except the specification of the
logic and the PDF file.

\hypertarget{creating-the-paper-latex}{%
\subsection{Creating the paper (LaTeX)}\label{creating-the-paper-latex}}

If you are interested in the LaTeX source of the paper, use
\passthrough{\lstinline!lgc2tex!} instead of
\passthrough{\lstinline!lgc2pdf!}:

\begin{lstlisting}
lgc2tex <name>
\end{lstlisting}

This will invoke MUltlog, but does neither LaTeXing nor cleaning up. It
will produce two files: \passthrough{\lstinline!<name>.tex!} and
\passthrough{\lstinline!<name>.sty!}.
\passthrough{\lstinline!<name>.tex!} is a template LaTeX file which
loads \passthrough{\lstinline!<name>.sty!}. The latter contains the
difinitions specific to your logic.

The source will be \passthrough{\lstinline!<name>.tex!} and will require
\passthrough{\lstinline!<name>.sty!} and to be compiled.
\passthrough{\lstinline!<name>.sty!} contains the definitions produced
by MUltlog.

\hypertarget{creating-the-paper-dvi}{%
\subsection{Creating the paper (DVI)}\label{creating-the-paper-dvi}}

The command

\begin{lstlisting}
lgc2dvi <name>
\end{lstlisting}

where \passthrough{\lstinline!<name>!} is the name under which you saved
your logic, will produce a DVI file of the paper.

\hypertarget{specification-of-a-logic}{%
\section{Specification of a logic}\label{specification-of-a-logic}}

The directory \passthrough{\lstinline!/usr/share/doc/multlog!} (or
whatever you chose) contains a documented example of the configuration
file format (as does the \passthrough{\lstinline!doc!} subdirectory of
the source distribution itself), \passthrough{\lstinline!sample.lgc!}.

To specify a logic, your specification (\passthrough{\lstinline!.lgc!})
file has to contain the following:

\hypertarget{the-name-of-the-logic-mandatory}{%
\subsection{The name of the logic
(mandatory)}\label{the-name-of-the-logic-mandatory}}

Here you specify the name of the logic to be used in the PDF.

Syntax:

\begin{lstlisting}
logic "<logname>".
\end{lstlisting}

where \passthrough{\lstinline!<logname>!} is a string described by the
regular expression RE1

({[}
\passthrough{\lstinline"!\#$\%\&'()*+,./0-9:;<=>?@A-Z[\\]\^\_`a-z\{|\}\~-"}{]}
\textbar{} \passthrough{\lstinline!""!} )*

of up to 40 characters. In other words, the string may consist of any
printable ASCII character, where quotes (``) have to be doubled.
\passthrough{\lstinline!<logname>!} may contain LaTeX code (e.g., for
accented characters), where \passthrough{\lstinline!\\!} does \emph{not}
need to be escaped.

Example:

\begin{lstlisting}
logic "G\""odel".
\end{lstlisting}

\hypertarget{truth-values-mandatory}{%
\subsection{Truth values (mandatory)}\label{truth-values-mandatory}}

You have to list the truth values of the logic you are defining. The
order in which they are listed will be the order used for the
presentation of truth tables. Every truth value may appear only once.

Syntax:

\begin{lstlisting}
truth_values { <v 1>, ..., <v n> }.
\end{lstlisting}

Example:

\begin{lstlisting}
truth_values {f,*,t}.
\end{lstlisting}

where each of the truth values \passthrough{\lstinline!<v 1>!}, \ldots,
\passthrough{\lstinline!<v n>!} (\(n \ge 2\)) is described by the
regular expression RE2

(
{[}\passthrough{\lstinline!a!}-\passthrough{\lstinline!z!}{]}{[}\passthrough{\lstinline!A-Za-z0-9\_!}{]}*
\textbar{} {[}\passthrough{\lstinline!-+*\^<>=\~?@\#$\&!}{]}+ \textbar{}
\passthrough{\lstinline!0!} \textbar{}
{[}\passthrough{\lstinline!1-9!}{]}{[}\passthrough{\lstinline!0-9!}{]}*
)

The truth values may consist of up to 10 characters. Unless you specify
how they should be typeset in the corresponding
\passthrough{\lstinline!.cfg!} file, the paper will use the names
\passthrough{\lstinline!<vn>!} in italics in the generated PDF.

\hypertarget{designated-truth-values-mandatory}{%
\subsection{Designated truth values
(mandatory)}\label{designated-truth-values-mandatory}}

The designated truth values are usually those representing ``true''. The
particular order of the values is of no significance as indicated by the
braces. Every truth value may appear at most once.

Syntax:

\begin{lstlisting}
designated_truth_values { <v 1>, ..., <v n> }.
\end{lstlisting}

Example:

\begin{lstlisting}
designated_truth_values {t}.
\end{lstlisting}

where each of the truth values \textless v 1\textgreater, \ldots,
(n\textgreater0) is described by the regular expression RE2 above and
may consist of up to 10 characters.

The choice of designated truth values has no effect on the generated
rules. However, they make a difference to what sequent, initial tableau,
or initial clause set has to be used to give a proof of an entailment.

\hypertarget{orderings-of-truth-values-optional}{%
\subsection{Orderings of truth values
(optional)}\label{orderings-of-truth-values-optional}}

By specifying an ordering on truth values, you can declare an operator
or quantifier as being the ``inf'' (greatest lower bound) or ``sup''
(least upper bound) operator with respect to the ordering.

Syntax:

\begin{lstlisting}
ordering(<ordname>, "<ordspec>").
\end{lstlisting}

where \passthrough{\lstinline!<ordname>!} is defined according to RE2
above and may consist of up to 10 characters.
\passthrough{\lstinline!<ordspec>!} is a string of up to 200 characters
satisfying RE1 above. This string is either a single chain, or a set of
chains in
\passthrough{\lstinline!\{!}\ldots{}\passthrough{\lstinline!\}!}. A
chain, in turn, is a seqence of either elements separated by
\passthrough{\lstinline!<!}, where each element is either a truth value
(as defined by \passthrough{\lstinline!truth\_values!}) or itself a set
of chains.

In order to avoid ambiguities, spaces may be used to separate the
\passthrough{\lstinline!<!} sign from truth values (which may also
contain the character \passthrough{\lstinline!<!}).

The semantics of order specifications is as follows:

\begin{itemize}
\tightlist
\item
  Chains like ``\passthrough{\lstinline!a < b < c < d < e!}'' are
  interpreted as an abbreviation for
  ``\passthrough{\lstinline!a < b, b < c, c < d, d < e!}''.
\item
  Independent chains are collected in sets:
  ``\passthrough{\lstinline!\{a < b, c < d <e, ...\}!}'';
\item
  Sets and chains can be nested. E.g.,
  ``\passthrough{\lstinline!a < \{b, c < d\} < e!}'' is the same as
  ``\passthrough{\lstinline!\{a < b, a < c, c < d, b < e, d < e\}!}''.
\end{itemize}

Let \(R\) be the relation defined by this specification. The ordering
induced by \(R\) is the smallest reflexive, anti-symmetric and
transitive relation containing \(R\). Note that truth values with
different names are treated as being different from each other. Hence a
specification containing \passthrough{\lstinline!a<b!} and
\passthrough{\lstinline!b<a!} induces no ordering, since anti-symmetry
would imply \passthrough{\lstinline!a!}=\passthrough{\lstinline!b!}.

Example:

\begin{lstlisting}
ordering(linear, "f < * < t").
\end{lstlisting}

\hypertarget{definitions-of-operators}{%
\subsection{Definitions of operators}\label{definitions-of-operators}}

Optional; but what's a logic without operators?

\hypertarget{mappings}{%
\subsubsection{Mappings}\label{mappings}}

In its simplest and most general form, each operator is specified by its
name and the mapping of input to output values. The braces indicate that
the order in which the input tuples are assigned output values is of no
significance. The definitions should be complete: every \(k\)-tuple has
to be assigned exactly one value, where \(k>0\) is the arity of the
operator. There may be several operators with the same
\passthrough{\lstinline!<opname>!} but with different
\passthrough{\lstinline!<arity>!}.

Syntax:

\begin{lstlisting}
operator(<opname>/<arity>, mapping { <ass 1>, ..., <ass m> }).
\end{lstlisting}

\passthrough{\lstinline!<opname>!} is defined according to RE2 above and
may consist of up to 10 characters. \passthrough{\lstinline!<arity>!} is
a non-negative integer. \passthrough{\lstinline!<ass 1>!}, \ldots,
\passthrough{\lstinline!<ass m>!} are assignments of the form

\begin{lstlisting}
( <v 1>, ..., <v k> ) : <v>
\end{lstlisting}

where
\passthrough{\lstinline!<v 1>!},\ldots,\passthrough{\lstinline!<v k>!},
and \passthrough{\lstinline!<v>!} are truth values. Assignments must be
separated by commas. For \(k = 0\), the mapping consists of a single
truth value.

Example:

\begin{lstlisting}
operator(true /0, mapping { t }).
operator(and  /2, mapping { (t,t): t,
                            (t,*): *,
                            (t,f): f,
                            (*,t): *,
                            (*,*): *,
                            (*,f): f,
                            (f,t): f,
                            (f,*): f,
                            (f,f): f
                          }
\end{lstlisting}

\hypertarget{tables}{%
\subsubsection{Tables}\label{tables}}

Binary operators can be also specified as tables. Since the order of
truth values in the table is significant, brackets are used instead of
braces.

Syntax:

\begin{lstlisting}
operator(<opname>/2, table [ <v 1>, ..., <v m> ]).
\end{lstlisting}

\passthrough{\lstinline!<opname>!} is defined according to RE2 above and
may consist of up to 10 characters.
\passthrough{\lstinline!<v 1>!},\ldots,\passthrough{\lstinline!<v m>!}
are truth values. The number of elements in the table, \(m\), has to be
equal to \((n+1)^2-1\), where \(n\) is the number of different truth
values.

Example:

\begin{lstlisting}
operator(and/2, table   [     t, *, f,
                          t,  t, *, f,
                          *,  *, *, f,
                          f,  f, f, f
                        ]
        ).
\end{lstlisting}

\hypertarget{inf-and-sup}{%
\subsubsection{Inf and sup}\label{inf-and-sup}}

Operators may also be declared to be the infimum (greatest lower bound)
or supremum (least upper bound) with respect to some user-defined
ordering.

Syntax:

\begin{lstlisting}
operator(<opname>/<arity>, sup(<ordname>)).
operator(<opname>/<arity>, inf(<ordname>)).
\end{lstlisting}

Here, \passthrough{\lstinline!<opname>!} is defined according to RE2
above and may consist of up to 10 characters.
\passthrough{\lstinline!<arity>!} is a non-negative integer greater than
one. \passthrough{\lstinline!<ordname>!} is the name of an appropriate
ordering defined by an \passthrough{\lstinline!ordering!} statement.

``sup'' stands for the least-upper-bound (= supremum) operation w.r.t.
the given ordering. The value of the operator is determined as the least
upper bound of the input truth values in the ordering. ``inf'' stands
for the greatest-lower-bound (= infimum) operation w.r.t. the given
ordering. The value of the operator is determined as the greatest lower
bound of the input truth values in the ordering.

The ordering has to define a unique supremum/infimum for any two truth
values.

Examples:

\begin{lstlisting}
operator(and  /2, inf(linear)).
operator(or   /2, sup(linear)).
\end{lstlisting}

\hypertarget{definitions-of-distribution-quantifiers}{%
\subsection{Definitions of (distribution)
quantifiers}\label{definitions-of-distribution-quantifiers}}

Optional.

\hypertarget{mappings-1}{%
\subsubsection{Mappings}\label{mappings-1}}

In its simplest and most general form, each quantifier is specified by
its name and a mapping assigning a truth value to each non-empty subset
of the truth values. The definitions should be complete: \emph{every}
non-empty subset should be assigned exactly one value.

Syntax:

\begin{lstlisting}
quantifier(<quname>, mapping { <ass 1>, ..., <ass m> }).
\end{lstlisting}

\passthrough{\lstinline!<quname>!} is defined according to RE2 above and
may consist of up to 10 characters.
\passthrough{\lstinline!<ass 1>!},\ldots,\passthrough{\lstinline!<ass m>!}
are assignments of the form
\passthrough{\lstinline!\{ <v 1>, ..., <v k> \} : <v>!}, where
\passthrough{\lstinline!<v 1>!},\ldots,\passthrough{\lstinline!<v k>!},
and \passthrough{\lstinline!<v>!} are truth values. \(k\) has to be
greater than one.

Example:

\begin{lstlisting}
quantifier(forall, mapping { {t}    : t,
                             {t,*}  : *,
                             {t,f}  : f,
                             {t,*,f}: f,
                             {*}    : *,
                             {*,f}  : f,
                             {f}    : f
                           }
          ).
\end{lstlisting}

\hypertarget{induced-quantifiers}{%
\subsubsection{Induced quantifiers}\label{induced-quantifiers}}

The definition of induced quantifiers in a more comfortable and less
error-prone form. Quantifiers can only be induced by operators which are
associative, commutative and idempotent.

Syntax:

\begin{lstlisting}
quantifier(<quname>, induced_by <opname>/<arity>).
\end{lstlisting}

\passthrough{\lstinline!<quname>!} is defined according to RE2 above and
may consist of up to 10 characters. \passthrough{\lstinline!<opname>!}
is defined according to RE2 above and may consist of up to 10
characters, and should be an operator defined as above.
\passthrough{\lstinline!<arity>!} is an integer greater than one.

Example:

\begin{lstlisting}
quantifier(forall, induced_by and/2).
\end{lstlisting}

\hypertarget{inf-and-sup-1}{%
\subsubsection{Inf and sup}\label{inf-and-sup-1}}

Quantifiers can also be induced by a lub/glb operator.

Syntax:

\begin{lstlisting}
quantifier(<quname>, induced_by <bop>(<ordname>)).
\end{lstlisting}

\passthrough{\lstinline!<quname>!} is defined according to RE2 above and
may consist of up to 10 characters. \passthrough{\lstinline!<bop>!} is
either sup or inf. \passthrough{\lstinline!<ordname>!} is the name of an
appropriate ordering defined by an
``\passthrough{\lstinline!ordering!}''-statement.

Example:

\begin{lstlisting}
quantifier(forall, induced_by inf(linear)).
\end{lstlisting}

\hypertarget{interactive-logic-creator}{%
\subsection{interactive Logic Creator}\label{interactive-logic-creator}}

\passthrough{\lstinline!ilc!} is a graphical front-end to make creating
\passthrough{\lstinline!.lgc!} files a little easier. It requires Tcl/Tk
(version 7.4/4.0 or later). To be exact, you only need the executable
\passthrough{\lstinline!wish!} (the windowing shell) but not the
libraries and none of the extensions.

The program should be rather self-explanatory once you know what goes
into the \passthrough{\lstinline!.lgc!} file. You can load and save
\passthrough{\lstinline!.lgc!} files from the ``File'' menu. Before you
can specify orderings, operators, and quantifiers, you have to enter the
name of the logic and the list of truth values.

\hypertarget{tex-configuration-files}{%
\section{TeX configuration files}\label{tex-configuration-files}}

MUltlog will generate a \passthrough{\lstinline!.tex!} and
\passthrough{\lstinline!.sty!} file from a given
\passthrough{\lstinline!.lgc!} file. If present, it will also use the
content of a corresponding \passthrough{\lstinline!.cfg!} file, which
can be used to fine-tune the formatted output.

The \passthrough{\lstinline!.cfg!} file for a logic can contain three
kinds of declaration:

\begin{itemize}
\item
  \passthrough{\lstinline!texName(<name>, <definition>)!} associates the
  name \passthrough{\lstinline!<name>!} of a truth value, operator, or
  quantifier used in the \passthrough{\lstinline!.lgc!} file with LaTeX
  code used to typeset it. For instance, if \passthrough{\lstinline!t!}
  is a truth value in the \passthrough{\lstinline!.lgc!} file, then

\begin{lstlisting}
texName(t, "\\mathbf{T}").
\end{lstlisting}

  will result in the truth value \passthrough{\lstinline!t!} be typset
  as \(\mathbf{T}\). (Note that \passthrough{\lstinline!\\!} have to be
  doubled.) If the LaTeX replacement is a simple command beginning with
  a lowercase letter, the quotation marks can be left off, e.g.,

\begin{lstlisting}
texName(and,    \\wedge  ).
\end{lstlisting}
\item
  \passthrough{\lstinline!texInfix(<op>)!} and
  \passthrough{\lstinline!texPrefix(<op>)!} will cause formulas
  involving an operator to be set either as infix or prefix, as opposed
  to the default operator notation. Of course,
  \passthrough{\lstinline!texInfix!} can only be applied to binary
  operators, and \passthrough{\lstinline!texPrefix!} only to unary
  operators. For instance:

\begin{lstlisting}
texInfix(or).
texPrefix(neg).
\end{lstlisting}
\item
  \passthrough{\lstinline!texExtra(<macro>, <definition>)!} will insert
  a definition for \passthrough{\lstinline!\\<macro>!} with body
  \passthrough{\lstinline!<definition>!} in the
  \passthrough{\lstinline!.sty!} file, which will be loaded in the
  preamble. This can be used to (re-)define any macro used in the LaTeX
  file. For instance,

\begin{lstlisting}
texExtra("ShortName", "\\textbf{\\L}_3").
\end{lstlisting}

  will define \passthrough{\lstinline!\\ShortName!} as
  \passthrough{\lstinline!\\textbf\{\\L\}\_3!}, and this macro will be
  available in the LaTeX file. The LaTeX template file makes use of a
  number of macros which can be defined in this way:

  \begin{itemize}
  \item
    \passthrough{\lstinline!\\Preamble!} will be executed in the
    preamble just before \passthrough{\lstinline!\\begin\{document\}!}.
    It can be used, e.g., to load packages needed for some of the
    operator symbols, or to change the document font.
  \item
    \passthrough{\lstinline!\\ShortName!} may contain code for an
    abbreviation or symbol for the logic.
    \passthrough{\lstinline!\\ShortName!} will be called in math mode.
  \item
    \passthrough{\lstinline!\\FullNameOfLogic!} is the macro used to
    insert the name of the logic. By default it will be
    ``\passthrough{\lstinline!<logname>!} logic''. Sometimes this
    doesn't work, so, e.g., you could say:

\begin{lstlisting}
texExtra("FullNameOfLogic", "Halld\\'en's logic of nonsense").
\end{lstlisting}
  \item
    \passthrough{\lstinline!\\Intro!} will be called (if defined) after
    the first paragraph of the introduction, and can be used to print a
    paragraph on the history or motivation of the logic. This paragraph
    can use \passthrough{\lstinline!\\cite!} to generate references to
    any entries in \passthrough{\lstinline!<logname>.bib!}.
  \item
    \passthrough{\lstinline!\\Semantics!} will be called just before the
    definition of the matrix of the logic. It can be used to print a
    paragraph, say, about the intuitive interpretation of the truth
    values, or how the truth functions of the operators are defined
    (say, on the basis of an ordering).
  \item
    \passthrough{\lstinline!\\Link!} will be added as a download link to
    the citation information at the bottom of the first page.
  \end{itemize}
\end{itemize}

Using

\begin{lstlisting}
texExtra("Preamble","\\ESequentstrue").
\end{lstlisting}

you can tell MUltlog to not use the compact representations of sequents,
but to explicitly list all components. This will only make sense if the
number of truth values is small. In this case, sequents are typeset
using the macro \passthrough{\lstinline!\\esequent!}. It expects an
argument consisting of the components of the sequent, separated by
commas. By default,

\begin{lstlisting}
\esequent{{\Gamma_1}, ..., {\Gamma_n}}
\end{lstlisting}

produces \(\Gamma_1 \mid \dots \mid \Gamma_n\). It can be redefined;
e.g., if you have a three-valued logic and want sequents displayed as
\(\Gamma_1 \Rightarrow \Gamma_2 \mid \Gamma_3\) you could do it using
the following \passthrough{\lstinline!Preamble!} declaration:

\begin{lstlisting}
texExtra("Preamble","\\ESequentstrue\\renewcommand{\\esequent}[1]{\\sequent##1}\\def\\sequent##1,##2,##3{##1 \\Rightarrow ##2 \\mid ##3}").
\end{lstlisting}

(Note the double \passthrough{\lstinline!\#!}.)

\hypertarget{interactive-use}{%
\section{Interactive use}\label{interactive-use}}

The command \passthrough{\lstinline!multlog!} will start Prolog and load
the MUltlog source files. This makes it possible to use MUltlog
interactively. This feature is expermiental and has not been tested
extensively. In particular, it does not yet include detailed error
checks.

\hypertarget{loading-and-saving-logics}{%
\subsection{Loading and saving logics}\label{loading-and-saving-logics}}

Interactive mode allows you to load the specification files of logics
and then perform queries and operations on these logics. To load a
logic, type, e.g.,

\begin{lstlisting}
?- loadLogic('lukasiewicz.lgc',luk).
\end{lstlisting}

Here, \passthrough{\lstinline!?-!} is the Prolog prompt; you only enter
the text after it. Now the definition of ﾅ「kasiewicz logic is available
using the ID \passthrough{\lstinline!luk!}.

You can save a logic as an \passthrough{\lstinline!.lgc!} file as well:

\begin{lstlisting}
?- saveLogic('name.lgc',id).
\end{lstlisting}

\hypertarget{displaying-a-logic}{%
\subsection{Displaying a logic}\label{displaying-a-logic}}

To display the truth values and truth tables of your logic, say

\begin{lstlisting}
?- showLogic(luk).
\end{lstlisting}

This will display the truth tables using the currently selected color
scheme. Color schemes are \passthrough{\lstinline!plain!},
\passthrough{\lstinline!designated!}, and \passthrough{\lstinline!all!}
and can be set using, e.g.,
\passthrough{\lstinline!setColors(luk,plain)!}. By default, logics have
color scheme \passthrough{\lstinline!all!} which displays different
values in different colors, with designated values reversed. This
requires an up-to-date version of SWI Prolog. Scheme
\passthrough{\lstinline!plain!} just displays all truth values in white,
and \passthrough{\lstinline!designated!} in white, but with designated
values reversed.

You can also output the truth tables in LaTeX format by saying
\passthrough{\lstinline!showLogic(luk, tex)!}. This will require some
definitions included in the preamble of your LaTeX document, which can
be displayed using \passthrough{\lstinline!showTexDefs!}.

\hypertarget{operating-with-formulas-and-truth-tables}{%
\subsection{Operating with formulas and truth
tables}\label{operating-with-formulas-and-truth-tables}}

Formulas of a logic are built using the operator names in the
\passthrough{\lstinline!.lgc!} file, in operator notation. Prolog
variables are used for propositional variables. So, e.g.,
\(X \to \lnot(X \lor Y)\) would be written as
\passthrough{\lstinline!imp(X, neg(or(X, Y)))!}. Instead of variables,
you can also put truth values of your logic, e.g.,
\passthrough{\lstinline!imp(t, neg(or(*,f)))!}. To find the value of
this formula:

\begin{lstlisting}
?- hasValue(luk,imp(t, neg(or(*,f))),V).
\end{lstlisting}

Prolog will display \passthrough{\lstinline!V =  (*)!}, i.e., the value
is \passthrough{\lstinline!*!}. If you hit space, Prolog will try to
find other solutions, and display \passthrough{\lstinline!false!} if no
other solutions can be found. In this case,
\passthrough{\lstinline!V=*!} is the only solution. However, if the
formula contains variables, Prolog will find all solutions. E.g.,

\begin{lstlisting}
?- hasValue(luk,imp(X, neg(or(X,Y))),f).
\end{lstlisting}

will successively find all values for the variables
\passthrough{\lstinline!X!} and \passthrough{\lstinline!Y!} so that the
value is \passthrough{\lstinline!f!}:

\begin{lstlisting}
X = t,
Y = f ;
X = t,
Y =  (*) ;
X = Y, Y = t ;
false.
\end{lstlisting}

The value can itself be a variable. For instance to find a truth value
fixed point of \(\lnot X \lor X\), type.

\begin{lstlisting}
?- hasValue(luk, or(X, neg(X)),X).
\end{lstlisting}

This will find solutions \passthrough{\lstinline!*!} and
\passthrough{\lstinline!t!}.

If you want to know if a formula is designated (or can be made
designated), use:

\begin{lstlisting}
?- isDesignated(luk, or(X, neg(X))).
\end{lstlisting}

This will find the values \passthrough{\lstinline!t!} and
\passthrough{\lstinline!f!}. Use
\passthrough{\lstinline!isUnDesignated!} instead if you are interested
in undesignated values.

To test if a formula is a tautology, say

\begin{lstlisting}
?- isTaut(luk, or(X, neg(X))).
\end{lstlisting}

This will just produce \passthrough{\lstinline!false!} since
\(X \lor \lnot X\) is not a tautology: if \(X\) is
\passthrough{\lstinline!*!} the result is \passthrough{\lstinline!*!},
which is not designated:

\begin{lstlisting}
?- isUnDesignated(luk, or(X, neg(X))).
X =  (*) 
\end{lstlisting}

To test for consequence, use

\begin{lstlisting}
?- isConseq(luk, [X, imp(X,Y)], Y).
\end{lstlisting}

Here, the second argument \passthrough{\lstinline![X, imp(X,Y)]!} is a
\emph{list} of formulas, and since in ﾅ「kasiewicz logic,
\(X, X \to Y \models Y\), this will result in
\passthrough{\lstinline!true!}.

You can also test for equivalence of two formulas:

\begin{lstlisting}
?- isEquiv(luk, or(X,Y), luk, imp(imp(X, Y), Y)).
\end{lstlisting}

Here, the first formula is evaluated according to the operations (truth
tables) of the first listed logic, and the second formula according to
the operations of the second logic. In this case we use the same logic
\passthrough{\lstinline!luk!} for both.

To find formulas with various properties, do the following:
\passthrough{\lstinline!findFmla(logic, F)!} will successively find
solutions \passthrough{\lstinline!F!} which are formulas of
\passthrough{\lstinline!logic!}. The solutions will be ugly, e.g.,
\passthrough{\lstinline!F = and(\_100, neg(\_136))!}
(\passthrough{\lstinline!\_!} followed by a number is Prolog's generic
way of naming variables). This can then be combined with other tests,
e.g., to find all tautologies, say:

\begin{lstlisting}
?- findFmla(luk,F), isTaut(luk, F).
\end{lstlisting}

The predicate \passthrough{\lstinline!findTaut(luk, F)!} does the same.

To find a formula equivalent to a given one, use
\passthrough{\lstinline!findEquiv!}, e.g.,

\begin{lstlisting}
?- findEquiv(luk, or(X,Y), luk, F).
\end{lstlisting}

will find all formulas \passthrough{\lstinline!F!} equivalent to
\(X \lor Y\). The first two are boring---\(X \lor Y\) itself and
\(Y \lor X\)---but then it will discover that you can express
\(X \lor Y\) using \((X \to Y) \to Y\) in ﾅ「kasiewicz logic.

To find only formulas not involving \(\lor\) here, you can define a
second version of ﾅ「kasiewicz logic without \(\lor\):

\begin{lstlisting}
?- loadLogic('lukasiewicz.lgc',luk2), delOp(luk2,or/2).
\end{lstlisting}

(\passthrough{\lstinline!delOp(luk2,op/2)!} deletes the 2-place operator
\passthrough{\lstinline!or!} from \passthrough{\lstinline!luk2!}.) Now

\begin{lstlisting}
?- findEquiv(luk, or(X,Y), luk2, F).
\end{lstlisting}

will only find formulas of \passthrough{\lstinline!luk2!} (i.e.,
formulas not containing \passthrough{\lstinline!or!}) that are
equivalent to \(X \lor Y\).

You can display a formula in a more readable format using
\passthrough{\lstinline!prettyFmla(F)!} or make a pretty copy of a
formula using \passthrough{\lstinline!prettyCopy(F, P)!}. For instance,
to find and print consequences of logic \passthrough{\lstinline!l1!}
that are invalid in \passthrough{\lstinline!l2!} you could say:

\begin{lstlisting}
?- findFmla(l1, and(A,B)), isConseq(l1, [A], B), \+ isConseq(l2, [A], B),
   prettyCopy((A,B), (Ap, Bp)),
   format('~w entails ~w in ~w but not in ~w~n', [Ap, Bp, l1, l2]).
\end{lstlisting}

Logic \passthrough{\lstinline!l1!} has to include a binary operator---in
this case \passthrough{\lstinline!and!}---to find two formulas
\passthrough{\lstinline!A!} and \passthrough{\lstinline!B!} with shared
variables. It's assumed that the operators of
\passthrough{\lstinline!l1!} are also operators of
\passthrough{\lstinline!l2!}.

\hypertarget{operating-on-logics}{%
\subsection{Operating on logics}\label{operating-on-logics}}

If you have two logics loaded or defined, you can have MUltlog define a
new logic as the direct product of the two.

\begin{lstlisting}
?- makeProduct(l1, l2, new).
\end{lstlisting}

The logic \passthrough{\lstinline!new!} is has truth values that are
pairs of truth values of the logics \passthrough{\lstinline!l1!} and
\passthrough{\lstinline!l2!}, with pairs where both components are
designated in \passthrough{\lstinline!l1!} and
\passthrough{\lstinline!l2!} being designated in
\passthrough{\lstinline!new!}, and operators defined componentwise. This
assumes that \passthrough{\lstinline!l1!} and
\passthrough{\lstinline!l2!} have the same operators defined.

To make a copy of a logic, say:

\begin{lstlisting}
?- copyLogic(l, new, 'Name').
\end{lstlisting}

The logic \passthrough{\lstinline!new!} is a copy of logic
\passthrough{\lstinline!l!} with name ``Name''.

You can change the disignated and undesignated values of a logic this
way:

\begin{lstlisting}
?- designateValues(l, [t, f]).
?- undesignateValues(l, [t, f]).
\end{lstlisting}

This will change the designated values of Logic
\passthrough{\lstinline!l!} to include (or exclude) the values
\passthrough{\lstinline!t!} and \passthrough{\lstinline!f!}.

\hypertarget{congruences-and-homomorphisms}{%
\subsection{Congruences and
homomorphisms}\label{congruences-and-homomorphisms}}

To find the congruences of a logic, say

\begin{lstlisting}
?- showCong(new).
\end{lstlisting}

This will look through all partitions of the designated and undesignated
values of logic \passthrough{\lstinline!new!} and test if the partition
is a congruence. If it is, it will display the partition of truth values
and the resulting truth tables, with congruent values colored
identically. Each class in the partition is a truth value in the factor
logic; truth values are congruent if they are elements of the same
class. Equivalent truth values ``behave the same'' on all operators,
e.g., if \(v\) and \(u\) are equivalent, then \(\lnot v\) and
\(\lnot u\) are also equivalent. Only ``strong'' congruences are found,
i.e., congruences that respect the designated values (i.e., designated
values are equivalent to other designated values, and undesignated
values to other undesignated values). (The first congruence found is
always the trivial one: every truth value is only equivalent to itself.)

Once you have a congruence, you can define a new logic as the factor
logic of the old one by

\begin{lstlisting}
?- makeFactor(logic, part, factor).
\end{lstlisting}

where \passthrough{\lstinline!logic!} is the ID of the old logic,
\passthrough{\lstinline!part!} is the set of sets of truth values that
defines the congruence (displayed by \passthrough{\lstinline!showCong!})
and \passthrough{\lstinline!factor!} is the ID of the new logic.

MUltlog can test if two logics are isomorphic, or if there is a
homomorphism from one to another:

\begin{lstlisting}
?- isIso(Iso, log1, log2).
?- isHom(Hom, log1, log2).
\end{lstlisting}

will succeed with \passthrough{\lstinline!Iso!}
(\passthrough{\lstinline!Hom!}) bound to a list of pairs of truth values
of logics \passthrough{\lstinline!log1!} and
\passthrough{\lstinline!log2!} which represents an isomorphism
(homomorphism), and fail if no isomorphism exists.

\begin{lstlisting}
?- showHom(Hom, log1, log2).
\end{lstlisting}

will display the homomorphism \passthrough{\lstinline!Hom!} in a nicer
format. To find and show all homomorhisms between
\passthrough{\lstinline!log1!} and \passthrough{\lstinline!log2!}, say:

\begin{lstlisting}
?- isHom(Hom, log1, log2), showHom(Hom, log1, log2), fail.
\end{lstlisting}

(The \passthrough{\lstinline!fail!} at the end will automatically find
all of them; otherwise you'll have to hit space to backtrack after
each.)

\hypertarget{troubleshooting}{%
\section{Troubleshooting}\label{troubleshooting}}

\hypertarget{installation-errors}{%
\subsection{Installation errors}\label{installation-errors}}

The installation script may produce the following warnings and errors.

\begin{itemize}
\item
  ``Error: \passthrough{\lstinline!<directory>!} does not exist.''

  The installation script did not find the directory for executables,
  library, or documentation (\passthrough{\lstinline!/usr/local/bin!},
  \passthrough{\lstinline!/usr/local/lib!}, and
  \passthrough{\lstinline!/usr/share/doc!} or
  \passthrough{\lstinline!\~/.local/bin!},
  \passthrough{\lstinline!\~/.local/lib!},
  \passthrough{\lstinline!\~./local/doc!} by default). Create the
  directories before running the script or select different directories
  when prompted.

  \begin{itemize}
  \tightlist
  \item
    ``Error: could not find Unix command
    \passthrough{\lstinline!<command>!}.'' where
    \passthrough{\lstinline!<command>!} is one of
  \end{itemize}

\begin{lstlisting}
basename chmod cp dirname false grep mkdir pwd rm sed true.
\end{lstlisting}

  The installation script and the scripts for starting MUltlog
  (\passthrough{\lstinline!lgc2tex!}, \passthrough{\lstinline!lgc2dvi!},
  \passthrough{\lstinline!lgc2pdf!}, and
  \passthrough{\lstinline!lgc2ilc!}) need these Unix commands. The error
  message means that could not be located, neither on the current
  command search path nor in the directories
  \passthrough{\lstinline!/usr/local/bin!},
  \passthrough{\lstinline!/usr/local/sbin!},
  \passthrough{\lstinline!/usr/bin!},
  \passthrough{\lstinline!/usr/sbin!}, \passthrough{\lstinline!/bin!},
  or \passthrough{\lstinline!/sbin!}. Locate the directory containing
  \passthrough{\lstinline!<command>!} and put it on your command search
  path during installation.

  If your Unix system does not have \passthrough{\lstinline!<command>!}
  at all, submit an issue on https://github.com/rzach/multlog/.
\item
  ``Warning: could not find TeX command
  \passthrough{\lstinline!<command>!}.'' where
  \passthrough{\lstinline!<command>!} is one of

\begin{lstlisting}
latex bibtex.
\end{lstlisting}

  The script \passthrough{\lstinline!lgc2dvi!} needs latex and bibtex to
  produce a DVI-file from the TeX document created by MUltlog. The
  warning means that \passthrough{\lstinline!<command>!} could not be
  located, neither on the current command search path nor in the
  directories

  \passthrough{\lstinline!/usr/local/bin!}
  \passthrough{\lstinline!/usr/local/!}sbin
  /usr/bin\passthrough{\lstinline!!}/usr/sbin\passthrough{\lstinline!!}/bin\passthrough{\lstinline!!}/sbin`

  Check whether TeX is properly installed and put the directory
  containing \passthrough{\lstinline!<command>!} on your command search
  path during installation.
\item
  ``Warning: couldn't find any PDF converters.''

  The script \passthrough{\lstinline!lgc2pdf!} needs either
  \passthrough{\lstinline!pdflatex!} or \passthrough{\lstinline!latex!},
  \passthrough{\lstinline!dvips!} and \passthrough{\lstinline!ps2pdf!}
  to produce a PDF-file from the TeX document created by MUltlog. The
  warning means that either \passthrough{\lstinline!pdflatex!} or
  \passthrough{\lstinline!dvips!} and \passthrough{\lstinline!ps2pdf!}
  could not be located, neither on the current command search path nor
  in the directories \passthrough{\lstinline!/usr/local/bin!},
  \passthrough{\lstinline!/usr/local/sbin!},
  \passthrough{\lstinline!/usr/bin!},
  \passthrough{\lstinline!/usr/sbin!}, \passthrough{\lstinline!/bin!},
  or \passthrough{\lstinline!/sbin!}. Check whether TeX and Ghostscript
  are properly installed and put the directory containing the PDF
  converter on your command search path during installation.
\item
  ``Warning: could not find Tcl/Tk command wish.''

  The editor \passthrough{\lstinline!ilc!} needs the Tcl/Tk package, in
  particular the program \passthrough{\lstinline!wish!}. The warning
  means that \passthrough{\lstinline!wish!} could not be located,
  neither on the current command search path nor in the in the
  directories \passthrough{\lstinline!/usr/local/bin!},
  \passthrough{\lstinline!/usr/local/sbin!},
  \passthrough{\lstinline!/usr/bin!},
  \passthrough{\lstinline!/usr/sbin!}, \passthrough{\lstinline!/bin!},
  or \passthrough{\lstinline!/sbin!}. Check whether Tcl/Tk is properly
  installed and put the directory containing
  \passthrough{\lstinline!wish!} on your command search path during
  installation.
\item
  ``Error: \passthrough{\lstinline!<command>!} does not exist or has no
  execute permission.''

  \passthrough{\lstinline!<command>!} (suggested by the user as Prolog
  interpreter) does not exist or cannot be executed.
\item
  ``Error: \passthrough{\lstinline!<command>!} does not behave like
  Prolog.''

  \passthrough{\lstinline!<command>!} (suggested by the user as Prolog
  interpreter) exists but fails the test performed by the installation
  script. This test is a heuristic check whether
  \passthrough{\lstinline!<command>!} is indeed a Prolog system; more
  precisely, the output of

\begin{lstlisting}
echo 'f(X,not)=f(ger,Y), print(X),print(Y),halt.' | <command>
\end{lstlisting}

  is checked for the string ``gernot''. If
  \passthrough{\lstinline!<command>!} is a Prolog system but fails this
  test, or if it is no Prolog system but passes the test, submit an
  issue on https://github.com/rzach/multlog/.
\end{itemize}

\hypertarget{runtime-errors}{%
\subsection{Runtime errors}\label{runtime-errors}}

\begin{itemize}
\item
  Warnings/errors about stack or heap overflows, like
  \passthrough{\lstinline!Out of global   stack!}.

  Such messages indicate that the Prolog system needs more space for the
  computation than it is currently granted. Check out by which option
  the space can be increased with your Prolog system. For SWI-Prolog,
  the command-line option \passthrough{\lstinline!--stack-limit=2g!}
  will increase the total stack limit from 1GB on 64-bit-architectures
  (512MB on 32-bit-architectures) to 2GB. There are three ways to tell
  MUltlog to use this option.

  \begin{itemize}
  \item
    \emph{For a single run:} Add the Prolog option as a further argument
    on the command line.

\begin{lstlisting}
lgc2pdf sample --stack-limit=2g
\end{lstlisting}
  \item
    \emph{Permanently during installation:} Re-install MUltlog. When the
    installation script asks for the Prolog to be used, type e.g.,
    \passthrough{\lstinline!/usr/bin/swipl --stack-limit=2g!}.
  \item
    \emph{Permanently after installation:} Add the option
    \passthrough{\lstinline!--stack-limit=2g!} manually, by editing the
    files

\begin{lstlisting}
/usr/local/bin/lgc2tex
/usr/local/bin/lgc2dvi
/usr/local/bin/lgc2pdf
/usr/local/lib/multlog/ilc/lgc2ilc
\end{lstlisting}

    Near their top there is a line starting with
    \passthrough{\lstinline!PROLOG=!}. Replace this line, e.g., by

\begin{lstlisting}
PROLOG='/usr/bin/swipl --stack-limit=2g'
\end{lstlisting}

    Make sure that the files have still execute permission after saving.
  \end{itemize}
\end{itemize}

\hypertarget{about-multlog}{%
\section{About MUltlog}\label{about-multlog}}

The following people contributed to MUltlog (in alphabetical order):

\begin{itemize}
\tightlist
\item
  Stefan Katzenbeisser and Stefan Kral rewrote the optimization
  procedure for operators using more efficient data structures.
\item
  Andreas Leitgeb is the author of iLC, the interactive Logic Creator.
\item
  Gernot Salzer wrote the MUltlog kernel and coordinated the project.
\item
  Richard Zach worked on the contents of the MUltlog paper and added the
  tableaux calculus.
\end{itemize}

\end{document}
